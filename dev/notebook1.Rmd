---
title: "R fundamentals"
output:
  html_document:
    number_sections: true
    css: /Users/jinwee/github/Return/themes_styles/main_style.css
    df_print: paged
---

# Introduction
This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing 

## About Rmarkdown
1. **General Markdown tips**
    1. **Use *1.* for every ordered list**
    1. 4 space indentation for nested list

1. **R Code Chunk options**
    1. **Ctrl+Shift+Enter**: Run R code chunk
    1. **include=bool**: Code always evaluated. Controls both code and results from appearing.
    1. **echo=bool**: Code always evaluated. Controls code from appearing **BUT RESULTS ALWAYS APPEAR.**
    1. **eva=bool**: Controls code evaluation. Code always appears.
    1. **results=""**: 
    1. **fig.cap/,hide = "..."**: Figure captions/hiding

1. **R Code Chunk tips**
    1. Code code chunks are not evaluated at preview. 
    1. Even though results = "hide" still shown in notebook, results are NOT knitted into output
    1. When code chunk options/ text are modified, code needs to be re-run before being previewed/knitted.
    

# R environment and setup

## R environment
```{r, eval=FALSE}  
##?read.table
find("read.table")
objects() # current variables
search() # attached packages and data.frames
detach() # detaches package
rm(list=ls()) ## removes all attached packages
```


## Setup dependencies and variables

```{r Dependencies, eval = TRUE, results="hide", message=FALSE, warning=FALSE}
# Importing necessary packages
library(tidyverse)
library(data.table)
library(datasets)
```

```{r Variables, eval= TRUE, results ='hide'}
# Setting variables
data(iris)
iris_dt <- data.table(iris)
```


## Global settings
```{r global knitr options, eval=TRUE}
knitr::opts_chunk$set(cache=FALSE, fig.align="center", collapse = TRUE, message=FALSE, warning=FALSE)
```


# General topics


## Data.table
The package data.table is written by Matt Dowle in year 2008.

Think of data.table as an advanced version of data.frame. It inherits from data.frame and works perfectly even when data.frame syntax is applied on data.table. This package is good to use with any other package which accepts data.frame.

### Basic dt operations and class data types

## String manipulation

### String functions
The various suite of functions for string manipulation
```{r string functions}
# Location
# grep() returns indices of matched items, while grepl() returns a logical vector to represent matches.
grep("A", c("ABC","DEF","CBA"))
grep("Z", c("ABC","DEF","CBA"))
grepl("A", c("ABC","DEF","CBA"))

# To find matching positions standardize and use gregexpr() because it gives ALL matches. Converting to vector to remove attributes.
gregexpr_output <- gregexpr("AB", c("ABC","DEF","CBA", "ABAAB"))
as.vector(gregexpr_output[[4]])
as.vector(gregexpr_output[[2]])

# Replacement 
# Sub only replaces the first occurrence of the pattern specified, gsub is global replacement
sub("A", "B", c("ABA","ZZZ"))
gsub("A", "B", c("ABA","ZZZ"))


# Splitting
# Note if pattern is repeated
strsplit("bbbAAAABE", "A")

# Extraction
```

### Regex
Using grep() for these regex examples
```{r regex}
regex_string <- "Many years later, as he faced the firing squad"
regex_vec <- c("AABAD ","ZADASSADF89", "adqw","ASSSSSDFAS'DFA", "Hippopotamus", "^[-]")

# Special characters
# There are some special characters in R that cannot be directly coded in a string. For example, apostrophes.
# Need to use escape character in our query string, also that "\" itself is a special character
# OH SHIT, WE NEED TO ESCAPE WITH A \ FOR REGEX, BUT THE \ ITSELF HAS TO BE ESCAPED FOR R
# AND WTF, \\\\
grep("\'", regex_vec)

# Anchors
grep("^A", regex_vec)
grep("A$", regex_vec)

# Quantifiers
# Note, by default, quantifiers are only applied to the immediate preceeding object/"character"
# Wildcard * number of '.', any character string
grep("^A.*A$", regex_vec)
# At least one / Zero or one
grep("AS+", regex_vec)
grep("AS?", regex_vec)
# Specifying quantities, exact, unlimited range, limited range
grep("AS{2}", regex_vec) # Note this still matches "ASSSSSDFASDFA"
grep("AS{2,}", regex_vec)
grep("AS{2,4}", regex_vec)

# Character sets
# Basically just to match at least one of the items in the set
# Note that we need an escape character in front of \set and that the captial version of the set is just the negation
# Note that the basic examples are just single character expressions, so "\\S", even if the query has even 1 non space character
grep("[0-9]", regex_vec)
grep("\\d", regex_vec)
grep("[A-Z]", regex_vec)
grep("\\w", regex_vec)
grep("[A-z]", regex_vec)
grep("\\s", regex_vec)
grep("\\S", regex_vec)
# More than 1 range and character in set, here 2 ranges and w
grep("[A-F0-9w]",regex_vec)
# Special characters in sets include: ], \, ^, - and must be escaped with \
grep("[\\[]",regex_vec)
grep("[\\]]",regex_vec) # Note, some error with \\]
grep("\\]",regex_vec)


# Operators   
# OR
# grep("(^A|A$)", regex_vec)
# strsplit(regex_vec[5], "(i|o)p")[[1]]
# strsplit(regex_vec[5], "[io]p")[[1]]
# regmatches(regex_vec[5], gregexpr("(i|o)p", regex_vec[5]))
# regmatches(regex_vec[5], gregexpr("[io]p", regex_vec[5]))
# AND


# ^ inverted character set
grep("AS{2}[^S]", regex_vec)
grep("AS{2}[^(S|A)]", regex_vec)
grep("AS{2}[^SZ]", regex_vec)


# Groupings and Bracket expressions 
#grep()







```

Combining regex expressions, varies whether or not the query is AND / OR


## List manipulation


# Data vizualization
















