---
title: "R fundamentals"
output:
  prettydoc::html_pretty:
    theme: architect
    highlight: vignette
    number_sections: true
    toc: true
    css: /Users/jinwee/github/Return/themes_styles/main_style.css
    df_print: paged
---

# Introduction
You can transform an R Markdown file in two ways, either by knitting it The rmarkdown package will call the knitr package. knitr will run each chunk of R code in the document and append the results of the code to the document next to the code chunk. Or converting the file. The rmarkdown package will use the pandoc program to transform the file into a new format, latex, html .. etc etc. Rendering is basically, knitting + converting.

In computer text processing, a markup language is a system for annotating a document in a way that is syntactically distinguishable from the text, meaning when the document is processed for display, the markup language is not shown, and is only used to format the text


## About Rmarkdown
1. **General Markdown tips**
    1. **Use *1.* for every ordered list**
    1. 4 space indentation for nested list

1. **R Code Chunk options**
    1. **Ctrl+Shift+Enter**: Run R code chunk
    1. **include=bool**: Code always evaluated. Controls both code and results from appearing.
    1. **echo=bool**: Code always evaluated. Controls code from appearing **BUT RESULTS ALWAYS APPEAR.**
    1. **eva=bool**: Controls code evaluation. Code always appears.
    1. **results=""**: Namesake, options: "hide"
    1. **fig.cap/,hide = "..."**: Figure captions/hiding

1. **R Code Chunk tips**
    1. Code code chunks are not evaluated at preview. 
    1. Even though results = "hide" still shown in notebook, results are NOT knitted into output
    1. When code chunk options/ text are modified, code needs to be re-run before being previewed/knitted.
    

# R environment and setup

## R environment
```{r, eval=FALSE}  
##?read.table
find("read.table")
objects() # current variables
search() # attached packages and data.frames
detach() # detaches package
rm(list=ls()) ## removes all attached packages
```


## Setup dependencies and variables

```{r Dependencies, eval = TRUE, results="hide", message=FALSE, warning=FALSE}
# Importing necessary packages
library(tidyverse)
library(data.table)
library(datasets)
```

```{r Variables, eval= TRUE, results ='hide'}
# Path variables
data_dir <- "/Users/jinwee/github/Return/data/"

# Data variables
data(iris)
iris_dt <- data.table(iris)
```


## Global settings
```{r global knitr options, eval=TRUE}
knitr::opts_chunk$set(cache=FALSE, fig.align="center", collapse = TRUE, message=FALSE, warning=FALSE)
```


# Data manipulation


## Data.table
The package data.table is written by Matt Dowle in year 2008.

Think of data.table as an advanced version of data.frame. It inherits from data.frame and works perfectly even when data.frame syntax is applied on data.table. This package is good to use with any other package which accepts data.frame.

A data.table is internally a list as well with all its columns of equal length.

### Basic dt operations and class data types

```{r reading and writing in data.table}
# All controls, sep, datatypes automatically detected by fread()
# Notable params: header=TRUE/FALSE, skip= nrows, select/drop= vec of colnames to keep/drop, col.names= vec of colnames, stringAsFactors
#flights_dt <- fread("https://raw.githubusercontent.com/Rdatatable/data.table/master/vignettes/flights14.csv")
#fwrite(flights_dt, file = file.path(data_dir,"flights.csv"))
flights_dt <- fread(file.path(data_dir,"flights.csv"))

claims <- data.table(
  ClaimNumber = c(123, 124, 125, 126),
  PolicyNumber = c(1, 1, 3, 4),
  ClaimCost = c(100, 2400, 350, 8000)
)

policies <- data.table(
  PolicyNumber = c(1, 2, 3),
  EffectiveDate = as.Date(c("2012-1-1", "2012-1-1", "2012-7-1")),
  ExpirationDate = as.Date(c("2012-12-31", "2012-6-30", "2012-12-31"))
)

```

```{r data.table column types/attributes etcetc, results = 'hide'}
# Possible colnames 
#  [1] "year"      "month"     "day"       "dep_delay" "arr_delay" "carrier"   "origin"    "dest"      "air_time" 
# [10] "distance"  "hour"   

# Familiar data.frame operations
rownames(flights_dt)
# colnames(flights_dt)
# nrow(flights_dt)
# ncol(flights_dt)
# flights_dt$carrier # indexed as vector 
# 
# # data.table styled commands, DT[i, j, by]
# # DT[subset, calculate/update, groupby]
# # Subsetting rows, note data.table does not support rownames
# select_rows <- c(1:5)
# flights_dt[1:5]
# flights_dt[origin == "JFK" & month == 6L]
# flights_dt[select_rows]
# flights_dt[!select_rows]
# 
# 
# # Subsetting columns
# select_cols <-  c("arr_delay", "dep_delay")
# flights_dt[, origin] #indexed as vector
# flights_dt[, !.(origin)] #indexed as dt, .() is basically an alias for list(), seems like colnames directly referenced in .()
# flights_dt[, !c("origin")]
# flights_dt[, c("origin","dest")]
# flights_dt[, .(time = air_time, dist = distance)] # renaming subsetted columns with list() system.
# flights_dt[, list(time = air_time, dist = distance)] # same thing with normal list
# flights_dt[, ..select_cols] # `..` look "up" one-level to look for the select_cols variable
# flights_dt[, !..select_cols]
# 
# 
# # Subsetting in i + Functions in j
# flights_dt[origin == "JFK" & month == 6L, .(m_arr = mean(arr_delay), m_dep = mean(dep_delay))]
# flights_dt[origin == "JFK" & month == 6L, .(n_obs = length(dest), n_obs2 = .N)] # get number of obs, .N stores n obs of current group
# 
# # Subsetting in i + Functions in j + aggregating by
# # Counts, mean, sum, unique
# flights_dt[origin != "JFK", .(counts = .N), by = .(origin)]
# flights_dt[carrier == "AA", .(counts = .N), by = .(origin, dest)]
# flights_dt[carrier == "AA", .(avg_arr_delay = mean(arr_delay), avg_dep_delay = mean(dep_delay) ), by = .(origin, dest, month)] 
# # Creating key and sorting output based on grouping variables with keyby
# flights_dt[carrier == "AA", .(avg_arr_delay = mean(arr_delay), avg_dep_delay = mean(dep_delay) ), keyby = .(origin, dest, month)] 
# 
# # Expressions in by
# # basically converting the columns we want to group by, into a diff vector.
# flights_dt[, .N, .(dep_delay>0, arr_delay>0)]
# flights_dt[, .N, .(paste0(origin,"_suffix"))]
# 
# 
# # Chaining
# flights_dt[carrier == "AA", .(avg_arr_delay = mean(arr_delay), avg_dep_delay = mean(dep_delay) ), by = .(origin, dest, month)][order(origin, avg_dep_delay)] 
# # chaining + assignment (note reference semantics for better version)
# #flights_dt$carrier[flights_dt$year == 2014] <- paste0(flights_dt$carrier[flights_dt$year == 2014] , "_suffx")
# 
# # SD
# # .SD. It stands for Subset of Data. It by itself is a data.table that holds the data for the current group defined using by.
# # by default, .SD includes all columns except grouping columns.
# #lapply(flights_dt, function(x) mean(x))
# flights_dt[, lapply(.SD, mean), by= .(carrier, origin, dest)]
# #note, .SDcols for specific columns
# 
# # Reference semantics
# # :=, := operator updates data.table columns in-place (by reference).
# # does NOT return anything, modifies in place, no repeat assignment 
# flights_dt[, `:=`(speed = distance / air_time)]
# flights_dt[year == 2014, carrier := paste0(carrier,"_suffix")]
# flights_dt[, c("origin", "dest") := NULL]
# flights_dt[, speed := NULL] # deleting column
# flights_dt[, c("origin", "dest") := NULL]
# 
# 

# # Additional parameters
# Returns row numbers that match condition
flights_dt[origin == "JFK", which = TRUE]


# # Joins
#The important thing to remember when doing a basic X[Y] join using data.table is that Y  will have all of its rows in the resultant table (unless otherwise specified). 
# colnames(claims) -> "ClaimNumber"  "PolicyNumber"(1,1,3,4) "ClaimCost"
# colnames(policies) -> "PolicyNumber"(1,2,3)   "EffectiveDate"  "ExpirationDate"
policies[claims,  on = .(PolicyNumber)] # alll claims, non-merged with NA entries 
policies[claims,  on = .(PolicyNumber), nomatch = NULL] # only claims that merge
claims[!policies,  on = .(PolicyNumber)] # entry of claims that dont merge
# non eqiuvalent join with condition
policies[, PolicyCost := 400]
policies[claims,  on = .(PolicyNumber, PolicyCost > ClaimCost)] # ClaimCost gets overwritten to PolicyCost?



```


## String manipulation

### String functions
The various suite of functions for string manipulation
```{r string functions}
# Location of matching strings
# grep() returns indices of matched items, while grepl() returns a logical vector to represent matches.
grep("A", c("ABC","DEF","CBA"))
grep("Z", c("ABC","DEF","CBA"))
grepl("A", c("ABC","DEF","CBA"))

# Location of matching positions
# To find matching positions standardize and use gregexpr() because it gives ALL matches.
gregexpr_output <- gregexpr("AB", c("ABC","DEF","CBA", "ABAAB"))
as.vector(gregexpr_output[[4]])
as.vector(gregexpr_output[[2]])

# Replacement 
# Sub only replaces the first occurrence of the pattern specified, gsub is global replacement
sub("A", "B", c("ABA","ZZZ"))
gsub("A", "B", c("ABA","ZZZ"))

# Splitting
# Note if pattern is repeated we get multiple empty strings
strsplit("bbbAAAABE", "A")

# Extraction


```

### Regex
Using grep() for these regex examples
```{r regex}
regex_string <- "Many years later, as he faced thefiringsquad"
regex_vec <- c("AABAD ","ZADASSADF89", "adqw","ASSSSSDFAS'DFA", "Hippopotamus", "^[-]")

# Special characters
# There are some special characters in R that cannot be directly coded in a string. For example, apostrophes.
# Need to use escape character in our query string, also that "\" itself is a special character
# OH SHIT, WE NEED TO ESCAPE WITH A \ FOR REGEX, BUT THE \ ITSELF HAS TO BE ESCAPED FOR R
# AND WTF, \\\\
grep("\'", regex_vec)

# Anchors
grep("^A", regex_vec)
grep("A$", regex_vec)
#\b is a 0-based matching (i.e the \b exactly matches the position) for: 1/2) Before/ after the first character in the string, if it is a word character. #3) between a word and non word character, effectively a whole word search.
# note that \B necessitates that the boundaries are word characters
# note that word characters,[^a-zA-Z0-9_], underscore and numbers included.
grep("\\bas\\b", regex_string)
regmatches(regex_string, gregexpr("\\Bfiring\\B", regex_string))
# note that \b can be used as an actual matching character when preceeded by a word 


# Quantifiers
# Note, by default, quantifiers are only applied to the immediate preceeding object/"character"
# Wildcard * number of '.', any character string
grep("^A.*A$", regex_vec)
# At least one / Zero or one
grep("AS+", regex_vec)
grep("AS?", regex_vec)
# Specifying quantities, exact, unlimited range, limited range
grep("AS{2}", regex_vec) # Note this still matches "ASSSSSDFASDFA"
grep("AS{2,}", regex_vec)
grep("AS{2,4}", regex_vec)

# Character sets
# Basically just to match at least one of the items in the set
# Note that we need an escape character in front of \set and that the captial version of the set is just the negation
# Note that the basic examples are just single character expressions, so "\\S", even if the query has even 1 non space character
grep("[0-9]", regex_vec)
grep("\\d", regex_vec)
grep("[A-Z]", regex_vec)
grep("\\w", regex_vec)
grep("[A-z]", regex_vec)
grep("\\s", regex_vec)
grep("\\S", regex_vec)
# More than 1 range and character in set, here 2 ranges and w
grep("[A-F0-9w]",regex_vec)
# Special characters in sets include: ], \, ^, - and must be escaped with \
grep("[\\[]",regex_vec)
grep("[\\]]",regex_vec) # Note, some error with \\]
grep("\\]",regex_vec)


# Operators   
# OR
# grep("(^A|A$)", regex_vec)
# strsplit(regex_vec[5], "(i|o)p")[[1]]
# strsplit(regex_vec[5], "[io]p")[[1]]
regmatches(regex_vec[5], gregexpr("[io]p", regex_vec[5])) #i/o position included in the match

# ^ inverted character set
grep("AS{2}[^S]", regex_vec)
grep("AS{2}[^(S|A)]", regex_vec)
grep("AS{2}[^SZ]", regex_vec)

# Look forward/behind
# (?=.), (?!.),  (?<=.), (?<!.) ,PERL = TRUE
regmatches(regex_vec[5], gregexpr("(?<=i|o)p", regex_vec[5], perl =TRUE)) #i/o position NOT included in the match
regmatches(regex_vec[5], gregexpr("p(?!p)", regex_vec[5], perl =TRUE)) #p position NOT included in the match

# Capturing groups and back references
# The part of input string matching the capturing group () is stored in a numbered "backreference"
# Note, we can also name capture groups, ?<foo>[abc])\k<foo>
# gregexpr(("(p|o)\\1"), regex_vec[5], perl = TRUE) ## capture group output not consistent
# gregexpr(("(?<foo>p|o)(?<foo2>p|o)"), regex_vec[5], perl = TRUE) ## capture group output not consistent.

# Ok lets think about how the search proceeds, this is basically a 2 character search, non-overlapping patterns
# If we want overlapping patterns, one character at a time, we need look ahead. 
as.vector(gregexpr(("(p|o)(p|o)"), regex_vec[5], perl = TRUE)[[1]])
as.vector(gregexpr(("(p|o)(?=p|o)"), regex_vec[5], perl = TRUE)[[1]])

```

Combining regex expressions, varies whether or not the query is AND / OR

## Factors



## List manipulation
```{r lists}
# Named list creation from vector
#setNames(values, name_vector)


```

# Data vizualization
















